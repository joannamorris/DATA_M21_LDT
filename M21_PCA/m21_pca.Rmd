---
title: "m21_pca"
author: "Joanna Morris"
date: "`r Sys.Date()`"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script computes the PCA for  Morph21.  


1. First we load the libraries we need

```{r}
library(tidyverse)
library(psych)
library(datawizard)
```

1. Set `ggplot2` parameters
```{r theme, echo = FALSE}
theme_set(theme_classic() +  
            theme(legend.position = "bottom", 
                  axis.text=element_text(size=10),
                  axis.title=element_text(size=9)))

# Define a custom color palette
my_palette <- c("#A6CEE3",  "#FB9A99")
my_palette_2 <- c( "#1F78B4","#E31A1C" )


# Create a function to apply this palette
scale_color_custom <- function() {
  scale_color_manual(values = my_palette_2)
}

scale_fill_custom <- function() {
  scale_fill_manual(values = my_palette)
}

library(dplyr)
library(purrr)

safe_bind_rows <- function(df1, df2) {
  # Get all unique column names
  all_cols <- union(names(df1), names(df2))
  
  # Add missing columns to each data frame
  for (col in setdiff(all_cols, names(df1))) {
    df1[[col]] <- NA
  }
  for (col in setdiff(all_cols, names(df2))) {
    df2[[col]] <- NA
  }
  
  # Reorder columns to match
  df1 <- df1[all_cols]
  df2 <- df2[all_cols]
  
  # Coerce columns to the same basic class
  df1 <- df1 %>%
    mutate(across(all_of(all_cols), ~ as_basic_type(.), .names = "tmp_{.col}")) %>%
    select(starts_with("tmp_")) %>%
    rename_with(~ sub("^tmp_", "", .x))
  
  df2 <- df2 %>%
    mutate(across(all_of(all_cols), ~ as_basic_type(.), .names = "tmp_{.col}")) %>%
    select(starts_with("tmp_")) %>%
    rename_with(~ sub("^tmp_", "", .x))
  
  # Final binding
  bind_rows(df1, df2)
}

# Helper function to drop extra classes and coerce to base types
as_basic_type <- function(x) {
  if (is.factor(x)) return(as.character(x))
  if (inherits(x, "Date")) return(as.Date(x))
  if (is.logical(x)) return(as.logical(x))
  if (is.numeric(x)) return(as.numeric(x))
  if (is.character(x)) return(as.character(x))
  if (inherits(x, "dw_transformer")) return(as.numeric(x))
  return(as.character(x))  # fallback
}
```

# Compute PCA

Following Andrews and Lo (2013) this script computes a PCA for our spelling and vocabulary measures. Because the standardised spelling and vocabulary scores were  correlated, to facilitate interpretation, two orthogonal measures of individual differences were derived from a principal components analysis. Analysis based on [this tutorial](http://www.sthda.com/english/articles/31-principal-component-methods-in-r-practical-guide/112-pca-principal-component-analysis-essentials/)

First we import the data, remove missing values adn standardize the scores.

```{r}


df1 <- read_csv("demo_lang_vsl.csv",   # loads demographic and languag data
    col_types = cols(TestSite = col_factor(levels = c("Hampshire", 
        "Providence")), `Included VSL2` = col_logical(), 
        `Included LDT` = col_logical(), Date = col_date(format = "%m/%d/%Y"), 
        Sex = col_factor(levels = c("Male", 
            "Female", "Prefer not to say")), 
        Ethnicity = col_factor(levels = c("Not Hispanic or Latino", 
            "Hispanic or Latino")), Race = col_factor(levels = c("Black", 
            "White", "Asian", "American Indian or Alaska Native", 
            "More than one race")), read_for_pleasure = col_factor(levels = c("Not at all only for school", 
            "1-3 hours", "4-6 hours", "6+ hours"))))

describe(df1)
```


```{r}
df1_cln <- df1 |>
  filter(!(is.na(spl_cor) | is.na(vcb_cor) | is.na(art_cor )))

df1_missing <- df1 |>
  filter((is.na(spl_cor) | is.na(vcb_cor) | is.na(art_cor )))

df1_cln_std <- mutate(df1_cln, 
                       z_vcb = standardise(vcb_cor),
                       z_spl = standardise(spl_cor),
                       z_art = standardise(art_diff))

```

Now we can put the three standardized measures into a separate data frame and compute the correlations, using the `cor()` function.  NB.  A correlation coefficient is a standardized covariance statistic. We can run the `cov()` function on the standardized values or the `cor()` function on the unstandardized ones.  Both methods will give the same results.

```{r}

art_vcb_spl_raw <- df1_cln_std |> select(SubjID,TestSite, vcb_cor, spl_cor, art_diff)
art_vcb_spl_z <- df1_cln_std |> select( SubjID,TestSite, z_vcb, z_spl, z_art) 

cor(art_vcb_spl_raw[,3:5], use = "everything", method = "pearson") 
cov(art_vcb_spl_z[,3:5], use = "everything", method = "pearson") 


```

Once we have generated the correlation coefficients we can test them for statistical significance.  You can only test one correlation at a time using the `cor.test()` function, but the `corr.test()` function in the `psych` package will test a matrix of correlation coefficients.

```{r}
corr.test(art_vcb_spl_z[,3:5]) 
```

Now we can do the PCA.  It turns out that by default, the function `PCA()` in `FactoMineR`, standardizes the data automatically, so we didn't actually need do the standardization.

Here are the arguments to the `PCA()` function:

- `X`: a data frame. Rows are individuals and columns are numeric variables

- `scale.unit`: a logical value. If TRUE, the data are scaled to unit variance before the analysis. This standardization to the same scale avoids some variables to become dominant just because of their large measurement units. It makes variables comparable.

- `ncp`: number of dimensions kept in the final results.

- `graph`: a logical value. If TRUE a graph is displayed.

The plot shows the relationships between all variables. It can be interpreted as follow:

- Positively correlated variables are grouped together.

- Negatively correlated variables are positioned on opposite sides of the plot origin (opposed quadrants).

- The distance between variables and the origin measures the quality of the variables on the factor map. Variables that are away from the origin are well represented on the factor map.

```{r}

library(FactoMineR)
library(factoextra)

res.pca <- PCA(art_vcb_spl_raw[,3:5], scale.unit = TRUE, ncp = 2, graph = FALSE)
plot(res.pca, choix = "varcor", graph.type = c("ggplot"))

res.pca <- PCA(art_vcb_spl_z[,3:5], scale.unit = TRUE, ncp = 2, graph = FALSE)
plot(res.pca, choix = "varcor", graph.type = c("ggplot"))
```

The eigenvalues measure the amount of variation retained by each principal component. Eigenvalues are large for the first PCs and small for the subsequent PCs. That is, the first PCs corresponds to the directions with the maximum amount of variation in the data set.

We examine the eigenvalues to determine the number of principal components to be considered. The sum of all the eigenvalues give a total variance of 3, the number of variables. An eigenvalue > 1 indicates that PCs account for more variance than accounted by one of the original variables in standardized data. This is commonly used as a cutoff point for which PCs are retained. This holds true only when the data are standardized.

```{r}
(eig.val <- get_eigenvalue(res.pca))
```


The quality of representation of the variables on factor map is called cos2 (square cosine, squared coordinates). *A high cos2 indicates a good representation of the variable on the principal component*. In this case the variable is positioned close to the circumference of the correlation circle.  *A low cos2 indicates that the variable is not perfectly represented by the PCs.* In this case the variable is close to the center of the circle. If a variable is perfectly represented by only two principal components (Dim.1 & Dim.2), the sum of the cos2 on these two PCs is equal to one. In this case the variables will be positioned on the circle of correlations.

```{r c4}
res.pca$var$cos2
```

The contributions of variables in accounting for the variability in a given principal component are expressed in percentages. Variables that are correlated with PC1 (i.e., Dim.1) and PC2 (i.e., Dim.2) are the most important in explaining the variability in the data set. The larger the value of the contribution, the more the variable contributes to the component. Itâ€™s possible to use the function corrplot() [corrplot package] to highlight the most contributing variables for each dimension.

```{r}
library('corrplot')
res.pca$var$contrib
corrplot(res.pca$var$contrib, is.corr=FALSE) 
```


The correlation between a variable and a principal component (PC) is used as the coordinates of the variable on the PC.

```{r}
(res.pca$var$coord)
(res.desc <- dimdesc(res.pca, axes = c(1,2), proba = 0.05))
```

The fviz_pca_ind() is used to produce the graph of individuals.

```{r c6}
ind <- get_pca_ind(res.pca)
fviz_pca_ind(res.pca)

```

add the individuals scores to the dataframe

```{r c7}
df1_cln_std_pca <- bind_cols(df1_cln_std,res.pca$ind$coord)
```


Divide participants based on median split of Dim2.  Higher values on this factor indicate that spelling scores were relatively higher than vocabulary

```{r}
df1_cln_std_pca <- df1_cln_std_pca |>
  mutate(lang_type_ortho = case_when(
    Dim.2 <= 0 ~ "Low Orthographic",
    Dim.2 > 0 ~ "High Orthographic"
  ))
df1_cln_std_pca <- df1_cln_std_pca |>
  mutate(lang_type_semantic = case_when(
    Dim.1 <= 0 ~ "Low Semantic",
    Dim.1 > 0 ~ "High Semantic"
  ))
```





```{r}
ggplot(data = df1_cln_std_pca, 
       aes(x = Dim.1, y = Dim.2, 
           colour = TestSite, 
           fill = TestSite)) +
  geom_point(size = 2.5) +
  scale_color_custom() +
  scale_fill_custom()
```



We can then write the indivdiual pca values to the original file

```{r}
df1_cln_std_pca_all <- safe_bind_rows(df1_cln_std_pca,df1_missing)

# Compare column classes side by side
compare_classes <- tibble(
  column = union(names(df1_cln_std_pca), names(df1_missing)),
  class_df1 = map_chr(column, ~ paste(class(df1_cln_std_pca[[.x]]), collapse = ", ")),
  class_df2 = map_chr(column, ~ paste(class(df1_missing[[.x]]), collapse = ", "))
)
print(compare_classes,n = 45)

# Example: convert all logical columns to 1/0
df1_cln_std_pca_all <- df1_cln_std_pca_all |>
  mutate(across(where(is.logical), as.integer))

# Write to CSV
write_csv(df1_cln_std_pca_all, "demo_lang_vsl_pca.csv")

```